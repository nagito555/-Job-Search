
import requests
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ContextTypes

HEADHUNTER_API_URL = "https://api.hh.ru/vacancies"
AREAS_API_URL = "https://api.hh.ru/areas"
DEFAULT_AREA =  96 # Ижевск 

user_areas = {}

def format_salary(salary):
    if not salary:
        return "Не указана"
    salary_from = salary.get('from')
    salary_to = salary.get('to')
    currency = salary.get('currency', '')
    if salary_from and salary_to:
        return f"{salary_from} - {salary_to} {currency}"
    if salary_from:
        return f"От {salary_from} {currency}"
    if salary_to:
        return f"До {salary_to} {currency}"
    return "Не указана"

def get_vacancies(query: str, area=DEFAULT_AREA, per_page=5):
    params = {
        "text": query,
        "area": area,
        "per_page": per_page,
        "page": 0,
        "only_with_salary": True
    }
    response = requests.get(HEADHUNTER_API_URL, params=params)
    if response.status_code != 200:
        return None
    data = response.json()
    results = []
    for item in data.get('items', []):
        name = item.get('name')
        employer = item.get('employer', {}).get('name', 'Не указана компания')
        city = item.get('area', {}).get('name', 'Не указан город')
        salary = format_salary(item.get('salary'))
        url = item.get('alternate_url')
        results.append(f"*{name}*\nКомпания: {employer}\nГород: {city}\nЗарплата: {salary}\n[Ссылка на вакансию]({url})")
    return results if results else ["Вакансий по запросу не найдено."]

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_areas[update.effective_user.id] = DEFAULT_AREA
    await update.message.reply_text(
        "Привет! Я бот-исследователь рынка труда.\n"
        "По умолчанию поиск ведётся по Ижевску (регион 96).\n"
        "Для изменения региона используйте команду:\n"
        "/region <номер_региона>\n"
        "Например: /region 2 (Санкт-Петербург)\n"
        "Чтобы получить список всех регионов, отправьте /areas\n\n"
        "Введите профессию или ключевое слово для поиска вакансий."
    )

async def set_region(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("Пожалуйста, укажите номер региона. Например: /region 2")
        return
    try:
        area = int(context.args[0])
    except ValueError:
        await update.message.reply_text("Номер региона должен быть числом. Попробуйте снова.")
        return
    user_areas[update.effective_user.id] = area
    await update.message.reply_text(f"Регион поиска установлен на: {area}")

async def list_areas(update: Update, context: ContextTypes.DEFAULT_TYPE):
    response = requests.get(AREAS_API_URL)
    if response.status_code != 200:
        await update.message.reply_text("Не удалось получить список регионов. Попробуйте позже.")
        return

    data = response.json()
    # Формируем список регионов первого и второго уровня (например, страны и регионы)
    # Для простоты выводим только регионы с id и названием во вложенных областях Москвы, СПб, и т.д.
    # Можно сделать более глубокий обход, но для краткости возьмём 2 уровня.
    regions = []

    def extract_areas(areas_list, prefix=""):
        for area in areas_list:
            regions.append(f"{prefix}{area['name']} - {area['id']}")
            if area.get('areas'):
                extract_areas(area['areas'], prefix=prefix+"  ")

    extract_areas(data)

    # Ограничим количество символов в сообщении (Telegram ~4096), поэтому разбиваем на части
    max_len = 4000
    text = "*Список регионов и их номеров:*\n"
    chunk = text
    for region in regions:
        if len(chunk) + len(region) + 2 > max_len:
            await update.message.reply_text(chunk, parse_mode='Markdown')
            chunk = ""
        chunk += region + "\n"
    if chunk:
        await update.message.reply_text(chunk, parse_mode='Markdown')

async def search_vacancies(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.message.text.strip()
    if not query:
        await update.message.reply_text("Пожалуйста, введите запрос для поиска вакансий.")
        return
    
    user_id = update.effective_user.id
    area = user_areas.get(user_id, DEFAULT_AREA)
    
    vacancies = get_vacancies(query, area=area)
    if vacancies is None:
        await update.message.reply_text("Произошла ошибка при обращении к API HeadHunter. Попробуйте позже.")
        return

    for vac in vacancies:
        await update.message.reply_text(vac, parse_mode='Markdown')

if __name__ == '__main__':
    application = ApplicationBuilder().token('').build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("region", set_region))
    application.add_handler(CommandHandler("areas", list_areas))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, search_vacancies))

    application.run_polling()
